# 锁

## 锁表、锁行

1. InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁；

2. InnoDB 自动给修改操作加锁，给查询操作不自动加锁

3. 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小

4. 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁

 

行锁大体两种：共享锁和排它锁，行锁是通过给索引上的索引项加锁来实现的。

共享锁（读锁、S锁）：允许事务读取一行数据；

排它锁（写锁、X锁）：允许事务删除或者更新一条数据。

## 悲观锁、乐观锁

**悲观锁**

悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。

**乐观锁**

乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁一般来说有以下2种方式：

1. 使用数据版本（Version）记录机制实现：数据库表增加version字段，修改时比较字段是否一致；

2. 使用时间戳（timestamp）：数据库表增加时间戳字段类型，更新提交时比较数据库和更新前取到是否一致；