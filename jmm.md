# Java内存模型（JMM）

**为什么要有内存模型：**

&emsp;&emsp;CPU（计算）速度快，内存（数据）跟不上，所以在CPU和内存之间增加高速缓存【CPU缓存分为：一级缓存（L1）、二级缓存（L2）和三级缓存（L3）】。多核CPU，每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。

​    ![单CPU双核的缓存结构](https://github.com/xubinlee/Notes/blob/master/assets/core-duo.png?raw=true) （单CPU双核的缓存结构）

**单线程**：CPU核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。

**单核CPU，多线程**：进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。

**多核CPU，多线程**：每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的cache中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。

​            ![](https://github.com/xubinlee/Notes/blob/master/assets/cache-inconsistency.png?raw=true)（多核CPU多线程缓存不一致）

注：缓存一致性问题（硬件问题）：

1. 多核CPU多线程场景，多个线程在不同的核心上写各自的缓存；

2. 处理器优化：为了使处理器内部的运算单元能够尽量充分利用，处理器可能会对输入代码进行乱序执行处理。

**什么是计算机内存模型：解决多线程场景下并发问题的一个重要规范**

&emsp;&emsp;Java内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程在工作内存中保存了该线程中用到的主内存的变量副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步。

**总结**：JMM是一种规范，目的是解决多线程通过共享内存进行通信时，存在本地内存数据不一致、编译器（如JIT）会对代码指令重排序、处理器会对代码乱序执行等带来的问题。

**Java内存模型的实现：** 

**原子性**是指在一个操作中CPU不可以在中途暂停然后再调度，即不被中断操作，要不执行完成，要不就不执行。

**可见性**是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

**有序性**即程序执行的顺序按照代码的先后顺序执行。

**原子性**

&emsp;&emsp;在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。

如何保证number++操作的原子性：

1. 使用synchronize关键字

2. 使用ReentrantLock
3. 使用AtomicInterger

**可见性**

&emsp;&emsp;Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。

&emsp;&emsp;Java中的volatile ['vɑlətl]关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。

&emsp;&emsp;除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。

1. synchronize可实现内存可见性和操作原子性

2. volatile（通过添加内存屏障来禁止指令重排）可实现内存可见性，但是不能保证操作原子性

3. 被final修饰的字段在构造器中一旦初始化完成，并且没有发生this逃逸（其他线程通过this引用访问到初始化了一半的对象），那么就实现线程可见。

volatile适用于读多写少的场景，valatile不会让线程阻塞，响应速度比synchronize高，这是它的优点。

**有序性**

&emsp;&emsp;在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。

实现方式区别：volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。

**内存语义：** 

&emsp;&emsp;锁获取与volatile读有相同的内存语义，锁释放与volatile写有相同的内存语义：

1. 锁获取时，JMM把该线程本地内存置为无效，线程将从主内存读取共享变量；

2. 锁释放时，JMM把该线程本地内存的共享变量刷新到主内存中。

公平锁和非公平锁内存语义总结：

l   公平锁和非公平锁释放时，都写volatile变量state。

l   公平锁获取时，首先读volatile变量。

l   非公平锁获取时，首先用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。